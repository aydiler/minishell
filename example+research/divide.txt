Coder A: Command Parsing and Built-in Commands

A. Command Parsing

Tokenization:
Implement the lexer to tokenize the input command line.
Handle single quotes ('), double quotes ("), and escaping.
Manage special characters like $ for environment variable expansion and $? for exit status.
Ensure unclosed quotes are detected and handled appropriately.

Syntax Parsing:
Build a parser to create an abstract syntax tree (AST) or similar structure.
Identify commands, arguments, redirections (<, >, <<, >>), and pipes (|).
Skip interpretation of backslashes (\) and semicolons (;) as per requirements.

B. Built-in Commands

Implement Built-ins:
echo (with -n option)
cd (handling relative and absolute paths)
pwd (print working directory)
export (manage environment variables)
unset (remove environment variables)
env (display environment variables)
exit (exit the shell)

Environment Variable Management:
Handle setting, updating, and removing environment variables.
Ensure that built-in commands interact correctly with the shell's environment.


Coder B: Command Execution and Shell Infrastructure

A. Command Execution

External Commands Execution:
Implement logic to execute external commands using fork() and execve().
Search for executables in PATH environment variable.
Handle absolute and relative paths.

Redirections and Pipes:
Manage input/output redirections (<, >, <<, >>).
Implement pipes (|) to connect multiple commands.
Handle file descriptors using dup, dup2, and pipe.

B. Shell Core Functionality

Prompt Display and Input Handling:
Use readline() to read user input.
Implement command history with add_history().
Handle end-of-file (Ctrl-D) and interrupts (Ctrl-C).

Signal Handling:
Set up signal handlers for SIGINT (Ctrl-C), SIGQUIT (Ctrl-), and EOF (Ctrl-D).
Ensure the shell responds correctly to user signals.

Global Variables for Signals:
Manage any required global variables for signal handling.
Ensure thread-safety and proper synchronization.